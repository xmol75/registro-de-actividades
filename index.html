
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/registro-de-actividades/" />
    <title>Registro de prolongaciones HUSE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🩺</text></svg>">

    <!-- 1. ES Module Shims (debe ir primero) -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js" crossorigin="anonymous"></script>

    <!-- 2. Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 3. Custom Fetch Hook para Transpilación con es-module-shims & Dynamic Script Load -->
    <script type="text/javascript">
      (async () => {
        // Esperar a que es-module-shims (importShim) y Babel estén cargados
        let attempts = 0;
        const maxAttempts = 200; // Esperar máximo 10 segundos (200 * 50ms)
        console.log("Fetch Hook Setup: Iniciando espera por importShim y Babel...");
        while ((typeof window.importShim === 'undefined' || typeof Babel === 'undefined') && attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 50)); 
          attempts++;
          if (attempts % 20 === 0) { // Log every second
             console.log(`Fetch Hook Setup: Esperando... (importShim: ${typeof window.importShim !== 'undefined'}, Babel: ${typeof Babel !== 'undefined'})`);
          }
        }

        if (typeof window.importShim === 'undefined' || typeof Babel === 'undefined') {
          console.error("Fetch Hook Setup: Error crítico: importShim o Babel no se cargaron a tiempo.");
          document.body.innerHTML = '<div style="color:red;padding:20px;">Error crítico al cargar dependencias (importShim o Babel). Revisa la consola.</div>';
          return;
        }
        console.log("Fetch Hook Setup: importShim y Babel están listos.");

        // Definir el fetch hook
        window.importShim.fetch = async function(url) {
          const actualUrl = typeof url === 'string' ? url : url.href; 
          
          try {
            console.log("Fetch Hook: Interceptando URL:", actualUrl);

            const response = await fetch(url); 

            if (!response.ok) {
              const responseBodyText = await response.text();
              console.error(`Fetch Hook: Falló el fetch original para ${actualUrl}. Estado: ${response.status} ${response.statusText}. Cuerpo (si existe):`, responseBodyText.substring(0, 500)); // Log more of the body
              
              if (actualUrl.endsWith('.tsx') || actualUrl.endsWith('.ts')) {
                const errorScriptContent = `
                  console.error("Fetch Hook (Error Handler): Módulo ${actualUrl} no pudo ser cargado. Estado: ${response.status}. El servidor respondió con: ${responseBodyText.substring(0, 200).replace(/`/g, '\\`').replace(/\${/g, '\\${') + '...'}");
                  throw new Error("Módulo ${actualUrl.replace(/"/g, '\\"')} no encontrado o error del servidor (Estado: ${response.status}).");
                `;
                return new Response(new Blob([errorScriptContent], { type: 'application/javascript' }), {
                  status: 200, 
                  headers: { 'Content-Type': 'application/javascript' }
                });
              }
              return new Response(responseBodyText, { 
                status: response.status, 
                statusText: response.statusText, 
                headers: response.headers 
              });
            }

            if (actualUrl.endsWith('.tsx') || actualUrl.endsWith('.ts')) {
              console.log(`Fetch Hook: ${actualUrl} es TSX/TS. Intentando transpilar.`);
              const source = await response.text();
              try {
                const { code } = Babel.transform(source, {
                  presets: ["react", "typescript"],
                  filename: actualUrl, 
                  sourceMaps: "inline", 
                });
                console.log(`Fetch Hook: Transpilación exitosa para ${actualUrl}.`);
                return new Response(new Blob([code || ''], { type: 'application/javascript' }), {
                  status: 200,
                  headers: { 'Content-Type': 'application/javascript' }
                });
              } catch (e) {
                console.error(`Fetch Hook: Falló la transpilación de Babel para ${actualUrl}:`, e);
                const errorMsg = (e.message || "Error desconocido de Babel").replace(/"/g, '\\"').replace(/\n/g, '\\n');
                const errorScript = `console.error("Error de transpilación en ${actualUrl.replace(/"/g, '\\"')} (via fetch hook): ${errorMsg}"); throw new Error("Error de transpilación en ${actualUrl.replace(/"/g, '\\"')}: ${errorMsg}");`;
                return new Response(new Blob([errorScript], { type: 'application/javascript' }), {
                  status: 200, 
                  headers: { 'Content-Type': 'application/javascript' }
                });
              }
            }
            console.log(`Fetch Hook: Pasando ${actualUrl} sin transpilar (no es TSX/TS).`);
            return response; 
          } catch (hookError) {
            console.error("Fetch Hook: Error INESPERADO dentro del hook:", hookError, "para URL:", actualUrl);
            const errorMsg = (hookError.message || "Error desconocido en fetch hook").replace(/"/g, '\\"').replace(/\n/g, '\\n');
            const urlString = actualUrl.replace(/"/g, '\\"');
            const errorScript = `console.error("Error crítico en fetch hook para ${urlString}: ${errorMsg}"); throw new Error("Error crítico en fetch hook para ${urlString}: ${errorMsg}");`;
            return new Response(new Blob([errorScript], { type: 'application/javascript' }), {
              status: 200, 
              headers: { 'Content-Type': 'application/javascript' }
            });
          }
        };
        console.log("Fetch Hook Setup: Hook para importShim.fetch definido.");

        // 5. Dinámicamente cargar el script principal de la aplicación
        console.log("Dynamic Load: Intentando cargar index.tsx como módulo...");
        const mainScript = document.createElement('script');
        mainScript.type = 'module';
        mainScript.src = './index.tsx'; // Ruta relativa, <base> se encargará
        mainScript.onerror = () => {
          console.error("Dynamic Load: Error al cargar el script principal index.tsx.");
          const rootEl = document.getElementById('root');
          if (rootEl) rootEl.innerHTML = '<div style="color:red;padding:20px;">Error crítico al cargar dinámicamente index.tsx. Revisa la consola para más detalles.</div>';
        };
        mainScript.onload = () => {
            console.log("Dynamic Load: index.tsx cargado (esto no significa que se haya ejecutado sin errores internos, solo que el tag &lt;script&gt; disparó onload).");
        };
        document.body.appendChild(mainScript);
        console.log("Dynamic Load: Tag de script para index.tsx añadido al DOM.");

      })();
    </script>

    <!-- 4. Import Map -->
    <script type="importmap">
    {
      "imports": {
        "react/": "https://esm.sh/react@^19.1.0/",
        "react": "https://esm.sh/react@^19.1.0",
        "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
        "uuid": "https://esm.sh/uuid@^9.0.1"
      }
    }
    </script>
</head>
  <body class="bg-slate-50 text-slate-800">
    <div id="root">Cargando aplicación...</div>
    <!-- El script principal se añade dinámicamente por el script anterior -->
  </body>
</html>
