
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/registro-de-actividades/" />
    <title>Registro de prolongaciones HUSE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🩺</text></svg>">

    <!-- 1. ES Module Shims (debe ir primero y ser síncrono o async pero gestionado) -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js" crossorigin="anonymous"></script>

    <!-- 2. Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 3. Custom Fetch Hook para Transpilación con es-module-shims -->
    <script type="text/javascript">
      (async () => {
        // Esperar a que es-module-shims (importShim) y Babel estén cargados
        let attempts = 0;
        const maxAttempts = 200; // Esperar máximo 10 segundos (200 * 50ms)
        while ((typeof window.importShim === 'undefined' || typeof Babel === 'undefined') && attempts < maxAttempts) {
          if (typeof window.importShim === 'undefined') console.log("Fetch Hook Setup: Esperando por importShim...");
          if (typeof Babel === 'undefined') console.log("Fetch Hook Setup: Esperando por Babel...");
          await new Promise(resolve => setTimeout(resolve, 50)); 
          attempts++;
        }

        if (typeof window.importShim === 'undefined' || typeof Babel === 'undefined') {
          console.error("Fetch Hook Setup: Error crítico: importShim o Babel no se cargaron a tiempo.");
          document.body.innerHTML = '<div style="color:red;padding:20px;">Error crítico al cargar dependencias (importShim o Babel). Revisa la consola.</div>';
          return;
        }
        console.log("Fetch Hook Setup: importShim y Babel están listos.");

        // Definir el fetch hook
        window.importShim.fetch = async function(url) {
          const actualUrl = typeof url === 'string' ? url : url.href; // Obtener URL como string
          
          try {
            console.log("Fetch Hook: Interceptando URL:", actualUrl);

            const response = await fetch(url); // Realizar el fetch original

            if (!response.ok) {
              const responseBodyText = await response.text();
              console.error(`Fetch Hook: Falló el fetch original para ${actualUrl}. Estado: ${response.status} ${response.statusText}. Cuerpo (si existe):`, responseBodyText);
              
              // Si el archivo es TSX/TS y no se encontró, devolvemos un módulo JS que tira un error.
              // Esto evita el error de MIME type si el servidor devuelve HTML (ej. una página 404).
              if (actualUrl.endsWith('.tsx') || actualUrl.endsWith('.ts')) {
                const errorScriptContent = `
                  console.error("Fetch Hook (Error Handler): Módulo ${actualUrl} no pudo ser cargado. Estado: ${response.status}. El servidor respondió con: ${responseBodyText.substring(0, 200).replace(/`/g, '\\`').replace(/\${/g, '\\${') + '...'}");
                  throw new Error("Módulo ${actualUrl.replace(/"/g, '\\"')} no encontrado o error del servidor (Estado: ${response.status}).");
                `;
                return new Response(new Blob([errorScriptContent], { type: 'application/javascript' }), {
                  status: 200, // Servimos como 200 OK, pero el contenido del script lanzará un error.
                  headers: { 'Content-Type': 'application/javascript' }
                });
              }
              // Para otros tipos de archivo, o si no es TSX/TS, devolvemos la respuesta original tal cual
              return new Response(responseBodyText, { 
                status: response.status, 
                statusText: response.statusText, 
                headers: response.headers 
              });
            }

            if (actualUrl.endsWith('.tsx') || actualUrl.endsWith('.ts')) {
              console.log(`Fetch Hook: ${actualUrl} es TSX/TS. Intentando transpilar.`);
              const source = await response.text();
              try {
                const { code } = Babel.transform(source, {
                  presets: ["react", "typescript"],
                  filename: actualUrl, 
                  sourceMaps: "inline", 
                });
                console.log(`Fetch Hook: Transpilación exitosa para ${actualUrl}.`);
                return new Response(new Blob([code || ''], { type: 'application/javascript' }), {
                  status: 200,
                  headers: { 'Content-Type': 'application/javascript' }
                });
              } catch (e) {
                console.error(`Fetch Hook: Falló la transpilación de Babel para ${actualUrl}:`, e);
                const errorMsg = (e.message || "Error desconocido de Babel").replace(/"/g, '\\"').replace(/\n/g, '\\n');
                const errorScript = `console.error("Error de transpilación en ${actualUrl.replace(/"/g, '\\"')} (via fetch hook): ${errorMsg}"); throw new Error("Error de transpilación en ${actualUrl.replace(/"/g, '\\"')}: ${errorMsg}");`;
                return new Response(new Blob([errorScript], { type: 'application/javascript' }), {
                  status: 200, 
                  headers: { 'Content-Type': 'application/javascript' }
                });
              }
            }
            console.log(`Fetch Hook: Pasando ${actualUrl} sin transpilar (no es TSX/TS).`);
            return response; 
          } catch (hookError) {
            console.error("Fetch Hook: Error INESPERADO dentro del hook:", hookError, "para URL:", actualUrl);
            const errorMsg = (hookError.message || "Error desconocido en fetch hook").replace(/"/g, '\\"').replace(/\n/g, '\\n');
            const urlString = actualUrl.replace(/"/g, '\\"');
            const errorScript = `console.error("Error crítico en fetch hook para ${urlString}: ${errorMsg}"); throw new Error("Error crítico en fetch hook para ${urlString}: ${errorMsg}");`;
            return new Response(new Blob([errorScript], { type: 'application/javascript' }), {
              status: 200, 
              headers: { 'Content-Type': 'application/javascript' }
            });
          }
        };
        console.log("Fetch Hook Setup: Hook para importShim.fetch definido.");
      })();
    </script>

    <!-- 4. Import Map -->
    <script type="importmap">
    {
      "imports": {
        "react/": "https://esm.sh/react@^19.1.0/",
        "react": "https://esm.sh/react@^19.1.0",
        "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
        "uuid": "https://esm.sh/uuid@^9.0.1"
      }
    }
    </script>
</head>
  <body class="bg-slate-50 text-slate-800">
    <div id="root">Cargando aplicación...</div>
    <!-- 5. Script principal de la aplicación, ahora como un módulo estándar -->
    <!-- es-module-shims interceptará esto y usará el fetch hook.
         La ruta es relativa y la etiqueta <base> la resolverá. -->
    <script type="module" src="./index.tsx"></script>
  </body>
</html>
